class Solution:

    def permute(self, nums: list) -> list:

        # Strategy:
        # This algorithm uses recursive call on self.get_permutation() to get
        # the rest of the permutations. We begin by turning nums from a list to a
        # set, nums_set. This is because we will be searching, adding and removing
        # elements from this set. These operations are faster with hashing. Also
        # initialize our current permutation and our final solution to []. Permutation
        # list will dynamically change and hold the current permutation.
        # self.get_permutations will be doing most of the work by recursively calling
        # itself and appending current permutation to our final solution.

        # Initialize our current permutation and our solution to an empty list.
        solution = []
        permutation = []

        # Turn nums from a list to a set, nums_set.
        nums_set = set(nums)

        # Call self.get_permutations() to do most of the work.
        self.get_permutations(nums_set, permutation, solution)

        # Return the solution generated by self.get_permutations().
        return solution

    def get_permutations(self, nums_set, permutation, solution):

        # The termination condition for self.get_permutation() is when nums_set
        # is empty. At this point, permutation list is ready to be added to our
        # solution list.
        if len(nums_set) == 0:
            solution.append(list(permutation))
            return

        # Otherwise, we iterate through nums_set, which may be smaller than the
        # original nums_set in size (new_nums_set of the caller).
        for n in nums_set:
            # Otherwise, we create a new nums_set to avoid changing the original
            # nums_set that we are currently iterating through.
            new_nums_set = set(nums_set)

            # We remove the element n from new_nums_set and append it to our
            # current permutation list.
            new_nums_set.remove(n)
            permutation.append(n)

            # Then recursively call self.get_permutations() with new_nums_set,
            # the current permutation list, and our current final solution list.
            self.get_permutations(new_nums_set, permutation, solution)

            # As we unwind the recursive calls, we pop the last element from
            # our current permutation list.
            permutation.pop(-1)

        return


l = [1,2,3]
sol = Solution().permute(l)
print(sol)
